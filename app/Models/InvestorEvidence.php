<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Support\Facades\Storage;

/**
 * @property int|string $id
 * @property int|string $investor_id
 * @property string $file_path           S3 object key (not a full URL)
 * @property string $storage_disk        Disk name (default: s3)
 * @property string|null $original_name
 * @property string|null $extension
 * @property string|null $mime
 * @property int|null $size
 * @property string|null $checksum_sha256
 * @property string $status
 * @property string|null $notes
 * @property int|null $uploaded_by
 *
 * @property-read string $url            Public (or signed) URL generated by the disk
 * @property-read string $filename       Basename of the S3 object key
 * @property-read string $size_human     Human readable size
 */
abstract class InvestorEvidence extends Model
{
    use HasFactory;

    /**
     * Child classes must set $table explicitly.
     * Example:
     *  protected $table = 'investor_spectro_evidences';
     */

    protected $fillable = [
        'investor_id',
        'file_path',
        'storage_disk',
        'original_name',
        'extension',
        'mime',
        'size',
        'checksum_sha256',
        'status',
        'notes',
        'uploaded_by',
    ];

    protected $casts = [
        'size' => 'integer',
        'uploaded_by' => 'integer',
    ];

    protected $attributes = [
        'storage_disk' => 's3',
        'status' => 'active',
    ];

    protected $appends = [
        'url',
        'filename',
        'size_human',
    ];

    /** Relationships */
    public function investor()
    {
        return $this->belongsTo(Investor::class);
    }

    public function uploader()
    {
        return $this->belongsTo(User::class, 'uploaded_by');
    }

    /** Accessors */
    public function getUrlAttribute(): ?string
    {
        if (!$this->file_path) return null;

        // If your S3 bucket is private and you need signed URLs, replace with temporaryUrl(...)
        // return Storage::disk($this->storage_disk)->temporaryUrl($this->file_path, now()->addMinutes(15));
        return Storage::disk($this->storage_disk)->url($this->file_path);
    }

    public function getFilenameAttribute(): ?string
    {
        return $this->file_path ? basename($this->file_path) : null;
    }

    public function getSizeHumanAttribute(): ?string
    {
        if (!$this->size) return null;

        $bytes = (int) $this->size;
        $units = ['B','KB','MB','GB','TB'];
        $i = $bytes > 0 ? (int) floor(log($bytes, 1024)) : 0;
        $i = min($i, count($units)-1);

        return sprintf('%.2f %s', $bytes / (1024 ** $i), $units[$i]);
    }

    /** Scopes */
    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    /** Clean up S3 object when the record is deleted */
    protected static function booted(): void
    {
        static::deleting(function (self $model) {
            if ($model->file_path && $model->storage_disk) {
                try {
                    $disk = Storage::disk($model->storage_disk);
                    if ($disk->exists($model->file_path)) {
                        $disk->delete($model->file_path);
                    }
                } catch (\Throwable $e) {
                    // swallow errors to avoid blocking the delete; log if desired
                    logger()->warning('Failed to delete evidence file from storage', [
                        'model' => static::class,
                        'id' => $model->id,
                        'disk' => $model->storage_disk,
                        'path' => $model->file_path,
                        'error' => $e->getMessage(),
                    ]);
                }
            }
        });
    }
}
